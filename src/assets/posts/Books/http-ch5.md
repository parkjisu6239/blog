# [HTTP 완벽 가이드] Chap5. 웹 서버

## 1. 다채로운 웹 서버

- 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.
- `웹 서버`라는 용어는 웹 서버 소프트웨어와 컴퓨터 양쪽을 모두 가리킨다.
- 웹 서버는 기능, 형태, 크기가 다양하다.
- 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.

### 1.1. 웹 서버 구현
- 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
- 웹 서버는 HTTP 프로토콜을 구현하고, 리소스를 관리하고, 서버 관리 기능을 제공한다.
- 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.
- 운영체제는 하드웨어를 관리하고, TCP/TP 네트워크 지원, 파일 시스템, 프로세스 관리를 제공한다.
- 웹 서버는 여러가지 형태가 가능하다.
  - 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치하고 실행할 수 있다.
  - 마이크로프로세서로 몇 개의 칩만으로 구현된 웹서버를 전자 기기에 내장시켜 완전한 콘솔로 제공한다.

### 1.2. 다목적 소프트웨어 웹 서버
- 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
  - 아파치, W3C의 직소 같은 오픈 소스 소프트웨어 사용 가능
  - 마이크로소프트, 아이플래닛 같은 상용 소프트워에 사용 가능

> [22년 기준](https://w3techs.com/)은 Nginx가 38%로 1등이다.

### 1.3. 임베디드 웹 서버
- 임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버이다. 예를 들면 프린터나 가전 제품이 있다.
- 몇몇 임베디드 웹 서버는 1제곱인치도 안되는 작은 크기로 구현되어 있고, 보통 최소한의 기능만을 제공한다.

## 2. 간단한 펄(Perl) 웹 서버
- 아파치 웹 서버의 코어는 5만 줄이 넘고, HTTP/1.1의 기능을 지원하려면 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 등등 각종 기능이 필요하다.
- 그러나 최소한의 기능을 하는 HTTP 서버는 30중 이하의 펄(Perl) 코드로 만들 수 있다.

```bash
#!/usr/bin/perl
use Socket;
use Carp;
use FileHandle;

# (1) 명령줄에서 덮어쓰지 않는 이상 8080 포트를 기본으로 사용한다. pport = (@ARGV ? $ARGV[0] : 8080);

# (2) 로컬 TCP 소켓을 생성하고 커넥션을 기다리도록 (listen) 설정한다.
$proto = getprotobyname('top');
socket (S, PF_INET, SOCK_STREAM, sproto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메시지를 출력한다.
printf(" <<<Type-o-Serve Accepting on Port %d>>>\n\n", $port);

while (1)
{
  # (4) 커넥션 C를 기다린다.
  $cport_caddr = accept(C, S);
  ($cport, $caddr) = sockaddr_in($cport_caddr); C->autoflush(1);

  # (5) 누구로부터의 커넥션인지 출력한다.
  $cname = gethostbyaddr($caddr, AF INET);
  printf(" <<<Request From '%s'>>>\n", $cname);

  # (6) 빈 줄이 나올 때까지 요청 메시지를 읽어서 화면에 출력한다. 
  while ($line = <C>)
  {
    print $line;
    if ($line =/^\r/) { last; }
  }


  # (7) 응답 메시지를 위한 프롬프트를 만들고, 응답줄을 입력 받는다.
  # "." 하나만으로 되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.

  printf(" <<<Type Response Followed by '.'>>>\n");
  while ($line = <STDIN>)
  {
    $line =~ /\//;
    $line =~ s/\n//;
    if (sline =~ /\./) { last; }
    print C $line . "\r\n";
    close(C);
  }
}

```

**type-o-server**

- 아래 코드는 `type-o-server` 라고 이름 붙은 작은 펄 프로그램이다.
- 이 프로그램은 클라이언트와 프락시 간의 상호작용 테스트에 유용한 진단 툴이다.
- 여느 웹 서버와 마찬가지로, type-o-server 는 HTTP 커넥션을 기다린다.
- type-o-server 는 요청 메시지를 받자마자, 화면에 출력한다.
- 그리고 클라이언트에게 답해줄 응답 페미지를 타이핑 하기를 기다린다.
- type-o-server 가 웹 서버를 흉내 내는 이 방식은, HTTP 요청 메시지를 정확하게 기록하고 어떤 HTTP 응답 메시지라도 돌려보내줄 수 있도록 해준다.

![type-o-server](image_http.assets/http-5-1.png)

**type-o-server로 HTTP 통신 테스트하기**
1. 관리자는 특정 포트로 수신하는 type-o-server 진단 서버를 시작한다. 8080포트를 사용한다(안쓰는 포트 아무거나 상관 없음) `% type-o-server.pl 8080`
2. tos가 동작하기 시작하면, 이 웹 서버에 브라우저로 접근할 수 있다.
3. tos 프로그램은 브라우저로부터 HTTP 요청을 받아, 그 내용을 화면에 출력한 후, 관리자가 마침표로 끝나는 응답 메시지를 입력할 때까지 기다린다.
4. tos는 HTTP 응답 메시지를 브라우저에 돌려주고, 브라우저는 응답 메시지의 본문을 출력한다.

## 3. 진짜 웹 서버가 하는 일

![web server](image_http.assets/http-5-2.png)

1. 커넥션을 맺는다. - 클라이언트의 접속을 받거나, 닫는다
2. 요청을 받는다. - HTTP 요청 메시지를 네트워크로부터 읽어들인다.
3. 요청을 처리한다. - 요청 메시지를 해석하고 행동을 취한다.
4. 리소스에 접근한다. - 메시지에서 지정한 리소스에 접근한다.
5. 응답을 만든다. - 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. 응답을 보낸다. - 응답을 클라이언트에게 돌려준다.
7. 트랜잭션을 로그로 남긴다. - 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

## 4. 단계 1: 클라이언트 커넥션 수락
지속 커넥션을 사용하거나, 새 커넥션을 열어 커넥션을 수락한다.

### 4.1. 새 커넥션 다루기
- 클라이언트가 웹 서버에 TCP 커넥션을 요청하면, 웹서버는 요청에서 IP를 추출하여 클라이언트를 확인한다.
- 커넥션이 받아들여지면, 서버는 새 커넥션을 커넥션 목록에 추가한다.
- 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.
  - 클라이언트의 IP 주소나 호스트명이 인가되지 않았거나 악의적일 경우 커넥션을 닫는다.
  - 다른 신원 식별 기법도 사용될 수 있다.

### 4.2. 클라이언트 호스트명 식별
- 대부분의 웹 서버는 `역방향 DNS(reverse DNS)` 를 사용해서 클라이언트의 IP 주소를 호스트명으로 변환한다.
- 호스트명은 구체적인 접근 제어와 로깅을 위해 사용될 수 있다.
- 호스트명 룩업(lookup)은 꽤 많은 시간이 걸려, 트랜잭션을 느려지게 하기도 한다.
- 많은 대용량 웹 서버는 호스트명 분석을 꺼두거나 특정 콘텐츠에 대해서만 켜놓는다.
- 아파치에서는 HostnameLookups 설정 지시자로 호스트 명 룩업을 켤 수 있다.

### 4.3. ident 를 통해 클라이언트 사용자 알아내기
- 몇몇 웹 서버는 IETF ident 프로토콜을 지원한다.
- ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화헀는지 찾아낼 수 있게 해준다.
- 이 정보는 특히 웹 서버 로깅에 유용하기 때문에, 널리 쓰이는 일반 로그 포맷의 두번째 필드는 각 HTTP 요청의 ident 사용자 이름을 담고 있다.
- 만약 클라이언트가 ident 프로토콜을 지원한다면, 클라이언트는 TCP 포트 113번을 listen 한다.

![ident]](image_http.assets/http-5-3.png)

ident는 조직 내부에서는 잘 사용할 수 있지만, 공공 인터넷에서는  신원 확인 프로토콜 미지원, 트랜잭션 지연, 방화벽, 프라이버스 등의 이유로 잘 동작하지 않는다.

## 5. 단계 2: 요청 메시지 수신
