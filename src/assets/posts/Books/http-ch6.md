# [HTTP 완벽 가이드] Chap6. 프락시

> 프락시란? 프락시는 클라이언트와 서버 사이에 위치하여 HTTP 메시지를 정리하는 중개인이다.

## 1. 웹 중개자
웹 프락시 서버는 클라이언트의 입장에서 트랙잭션을 수행하는 중개인이다.

- 프락시 서버가 없다면: 클라이언트와 HTTP 서버 직접 통신
- 프락시 서버가 있다면: 클라이언드 → 프락시 → HTTP 서버 형태로 통신
- 프락시 서버는 서버이면서 동시에 클라이언트여야 한다.

### 1.1. 개인 프락시와 공유 프락시

#### 공용 프락시
- 대부분의 프락시는 공용이며 공유된 프락시다. 
- 중앙 집중형이 효율이 높고 관리가 쉽다.
- 몇몇 프락시를 사용하는 어플리케이션은 사용자가 많을수록 여러 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문에 더 유리하다.

#### 개인 프락시
- 하나의 클라이언트만을 위한 프락시
- 흔하지는 않지만 브라우저의 기능을 확장하거나 성능을 개선하는 등 작은 프락시를 사용자의 컴퓨터에서 직접 실행하는 형태로 꾸준히 사용되고 있다.

### 1.2. 프락시 대 게이트웨이

|프락시|게이트웨이|
|---|---|
|같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결|다른 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결. 클라이언트와 서버가 사용하는 프로토콜이 다른 경우 적절히 변환한다.|

> 프락시도 서로 다른 HTTP 버전을 사용하는 디바이스를 위해 때때로 약간의 프로토콜 변환을 수행한다. 그리고 상용 프락시 서버는 SSL, SOCKS, FTP, 게이트웨이 기능을 지원한다.

## 2. 왜 프락시를 사용하는가?
- 보안을 개선한다.
- 성능을 높여준다.
- 비용을 절약한다.
모든 HTTP 트래픽을 들여다보고 건드릴 수 있다.

#### 어린이 필터
- 성인 콘텐츠 차단을 위한 필터링 프락시 사용
- 부적절한 컨텐츠 접근 제어


#### 문서 접근 제어자
- 많은 웹 서버들과 웹 리소스에 대한 단일한 접근 제어 전략을 구현하고 감사 추적(audit trail)하기 위해 사용
- 대기업 환경이나 분산된 관료 조직에서 유용
- 중앙 프락시 서버에서 접근 제어를 설정할 수 있다.

#### 보안 방화벽
- 보안을 강화하기 위해 프락시 서버는 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제할 수 있다.

#### 웹 캐시
- 프락시 캐시는 인기 있는 문서의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공하여 느리고 비싼 인터넷 커뮤니케이션을 줄여준다.

#### 대리 프락시(리버스 프락시)
- 웹 서버인 것처럼 위장해서 진짜 웹 서버 요청을 받는다.
- 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션한다.
- 이런식으로 사용하는 대리 프락시를 서버 가속기라고 부른다.

#### 콘텐츠 라우터
- 인터넷 트래픽 조건과 컨텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작할 수 있다.
- 만약 사용자가 더 높은 성능을 위해 돈을 지불했다면 요청을 더 가까운 복제 캐시로 전달할 수 있고, 필터링 서비스에 가입했다면 HTTP 요청이 필터릭 프락시를 통과하도로 할 수 있다.

#### 트랜스코더
- 서버 -> 클라이언트 중간에서 응답 본문 포맷을 수정한다.
- 콘텐츠 크기를 줄이거나, 색강도를 줄이거나, 압축, 번역 등등을 수행한다.

#### 익명화 프락시
- HTTP 메세지에서 신원을 식별할 수 있는 특성들을 제거하여 개인 정보 보호, 익명성 보장에 기여할 수 있다.
- User-agent, From, Referer, Cookie 등을 지우거나 변경한다.

## 3. 프락시는 어디에 있는가?

### 3.1. 프락시 서버 배치
어떻게 사용할지에 따라 어디에든 배치할 수 있다.

#### 출구(Egress) 프락시(개인 LAN 출구 프락시)
- 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 로컬 네트워크의 출구에 배치할 수 있다.
  - 악의적인 해커들을 막는 방화벽 제공하기 위해
  - 인터넷 요금을 절약하고 트래픽 성능을 개선하기 위해
  - 어린 학생들의 부적절한 콘텐츠를 막기 위해

#### 접근(입구) 프락시 (ISP 접근 프락시)
- 고객으로부터 모든 요청을 종합적으로 처리하기 위해 프락시를 ISP 접근 지점에 배치할 수 있다. 
- 이를 통해 다운로드 속도를 개선하거나 캐시 프락시를 사용해 많이 찾는 문서의 사본을 저장할 수 있다.

#### 대리 프락시
- 대리 프락시(또는 리버스 프락시)는 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치한다.
- 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청할 수 있다.
  - 웹 서버에 보안 기능을 추가
  - 웹 서버 캐시를 느린 웹 서버의 앞에 놓아 성능을 개선

#### 네트워크 교환 프락시
- 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고 트래픽 흐름을 감시하기 위해 네트워크 사이의 인터넷 피어링 교환 지점들에 놓일 수 있다.


### 3.2. 프락시 계층
프락시들은 프락시 계층이라고 불리는 연쇄를 구성할 수 있다. 프락시 계층에서 프락시 서버들은 부모와 자식 관계를 갖는다.
- 부모: 다음번 인바운드 프락시, 서버와 가까운 쪽
- 자식: 다음번 아웃바운드 프락시, 클라이언트와 가까운 쪽

#### 프락시 계층 콘텐츠 라우팅
- 자식 프락시는 부모 프락시로 메시지를 보낸다.
- 프락시 서버는 여러 판단에 의해 메시지를 유동적인 프락시 서버와 원 서버들의 집합에게 보낼 수 있다.
- 요청된 객체가 콘텐츠 분산을 위해 돈을 지불한 웹 서버에 속한 경우, 프락시는 요청을 가까운 캐시 서버에게 보내 캐시된 객체를 반환하거나 그럴 수 없을 때는 서버에서 가져오게 할 수 있다.
- 요청이 특정 종류의 이미지에 대한 것인 경우, 접근 프락시는 그 요청을 특화된 압축 프락시에게 보내 이미지를 압축하여 빠르게 다운로드할 수 있게 한다.

동적 부모 선택의 몇가지 예를 들면 다음과 같다.
- 부하 균형 : 자식 프락시는 부하를 분산하기 위해 부모의 작업량 수준에 근거하여 부모 프락시를 고른다.
- 지리적 인접성에 근거한 라우팅 : 원 서버의 지역을 담당하는 부모를 선택할 수도 있다.
- 프로토콜/타입 라우팅 : URI에 근거하여 다른 부모나 원 서버로 라우팅할 수 있다.
- 유료 서비스 가입자를 위한 라우팅 : 유료 서비스 가입자의 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅될 수 있다.


### 3.3. 어떻게 프락시가 트래픽을 처리하는가
클라이언트 트래픽이 프락시로 가도록 만드는 방법에는 네 가지가 있다.

#### 클라이언트를 수정한다.
- 많은 웹 클라이언트들은 수동, 자동 프락시 설정을 지원한다.
- 클라이언트가 프락시를 사용하도록 설정되어 있다면 HTTP 요청을 의도적으로 프락시로 보낸다.

#### 네트워크를 수정한다.
- 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가도록 조정할 수 있다. 
- 일반적으로 클라이언트 모르게 트래픽을 프락시로 보내는 스위칭 장치와 라우팅 장치를 필요로 한다.
- 이것을 `인터셉트 프락시`(또는 투명 프락시(transparent proxy))라고 부른다.

#### DNS 이름공간을 수정한다.
- 웹 서버 앞에 위치하는 대리 프락시는 웹 서버의 이름과 IP 주소를 자신이 직접 사용한다.
- 그래서 모든 요청이 서버 대신 대리 프락시로 간다.
- 이는 동적 DNS 서버를 이용해 조정될 수 있다.

#### 웹 서버를 수정한다.
- 몇몇 웹 서버는 HTTP 리다이렉션 명령(응답코드 305)을 클라이언트에게 돌려줘서 클라이언트의 요청을 프락시로 리다이렉트 하도록 설정할 수 있다.


## 4. 클라이언트 프락시 설정
모든 현대적인 브라우저는 프락시를 사용할 수 있도록 설정할 수 있다.

- 수동 설정: 프락시를 사용하겠다고 명시적으로 설정하는 것.
- 브라우저 기본 설정: 브라우저 벤더나 배포자는 프락시를 미리 설정해놓을 수 있다.
- 프락시 자동 설정(Proxy auto-configuration, PAC): 자바스크립트 프락시 자동 설정(PAC) 파일에 대한 URI를 제공할 수 있다.
- WPAD 프락시 발견: 대부분의 브라우저는 프락시 자동 설정 파일(PAC)을 받을 수 있는 설정서버를 자동으로 찾아주는 프로토콜을 제공한다.

### 4.1. 클라이언트 프락시 설정: 수동
- 많은 웹 클라이언트가 프락시를 수동으로 설정할 수 있도록 하고 있다. 
- 프락시의 호스트와 포트를 지정할 수 있다.
- 단순하지만 유연하지 못하다.
  - 모든 콘텐츠를 위해 단 하나의 프락시 서버만 지정 가능
  - 장애시의 대체 작동에 대한 지원 없음
  - 큰 조직에서 관리 문제 야기

### 4.2. 클라이언트 프락시 설정: PAC 파일
- 프락시 자동 설정(PAC) 파일은 상황에 맞게 프락시 설정을 계산해주는 자바스크립트 프로그램이기 때문에 동적으로 적절한 프락시 서버를 선택하는 것이 가능하다.
- 각 PAC 파일은 반드시 URI에 접근할 때 사용할 적절한 프락시 서버를 계산해주는 FindProxyForUrl(url, host)라는 함수를 정의해야 한다.

|반환 값|설명|
|---|---|
|DIRECT| 프락시를 통해 이동하지 않고 서버에 직접 연결.|
|PROXY host:port| 지정된 프락시와 포트 번호를 사용. 여러 값을 세미 콜론으로 구분한 경우 첫 번째 프락시가 사용되며, 해당 프락시가 실패할 경우 다음 프락시가 차례대로 사용.|
|SOCKS host:port| 지정된 SOCKS 서버를 사용. 여러 값을 세미 콜론으로 구분한 경우 첫 번째 프락시가 사용되며, 해당 프락시가 실패할 경우 다음 프락시가 차례대로 사용.|

#### 클라이언트 프락시 설정: WPAD
- 웹 프락시 자동 발견 프로토콜(WPAD)은 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘이다. 
- WPAD는 올바른 PAC 파일을 알아내기 위해 일련의 리소스 발견 기법을 사용하는데, 성공할 때 까지 각 기법을 하나씩 시도해본다.

## 5. 프락시 요청의 미묘한 특징들
### 5.1. 프락시 URI는 서버 URI와 다르다.
- 클라이언트 대신 프락시가 요청을 보내면 요청의 URI가 달라진다.
- 클라이언트 -> 프락시 : 스킴, 호스트, 포트번호가 없는 부분 URI
- 프락시 -> 서버 : 완전한 URI

```
// 클라이언트 -> 프락시
GET /index.html HTTP/1.0
User-Agent: SuperBrowserv1.3

// 프락시 -> 서버
GET http://www.marys-antiques.com/index.html HTTP/1.0
User-Agent: SuperBrowserv1.3
```
> 원래의 HTTP 설계에서 가상 호스팅이 존재하지 않았고, 클라이언트는 단일한 서버와 직접 대화했기에 불필요한 정보 발송을 피하기 위해 부분 URI를 보냈지만, 프락시는 목적지 서버와 커넥션을 맺어야 하기 때문에 그 서버의 이름을 알 필요가 있어 완전한 URI로 보내야 한다.

### 5.2. 가상 호스팅에서 일어나는 같은 문제
- 가상으로 호스팅되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유한다.
- 요청 하나가 부분 URI(/index.html 등)로 오면 웹 서버는 그 요청이 접근하고자 하는 웹 사이트의 호스트명을 알 필요가 있다.
- 명시적인 프락시는 완전한 URI를 사용하여 이 문제를 해결.
- 가상으로 호스팅되는 웹 서버는 호스트와 포트에 대한 정보가 담긴 Host 헤더를 요구한다.

### 5.3. 인터셉트 프락시는 부분 URI를 받는다
- 클라이언트가 HTTP를 올바르게 구현했다면, 그들은 명시적으로 설정된 프락시에게는 완전한 URI를 보낼 것이다.
- 하지만 몇몇 프락시는 클라이언트에게 보이지 않아, 프락시의 존재를 항상 알 수는 없다. 
- 클라이언트가 프락시 사용을 설정하지 않아도 동작하는 대리 프락시, 인터셉트 프락시를 지날 수 있다.
- 이 때 명시적으로 프락시 설정을 하지 않았기 때문에 웹 서버와 통신하고 있다고 생각하고 부분 URI 요청을 보내게 될 것이다.


### 5.4. 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다.
- 트래픽이 서버로 리다이렉트될 수 있는 여러 방법이 존재하기 때문에 다목적 프락시는 완전한 URI, 부분 URI를 모두 지원해야 한다.
- 명시적 프락시 요청에 대해선 완전한 URI, 그게 아니면 부분 URI, 웹 서버 요청의 경우엔 가상 Host 헤더를 사용해야 한다.

완전 URL과 부분 URL을 사용하는 규칙
- 완전한 URI가 주어지면 그것을 사용한다.
- 부분 URI, 가상 Host 헤더가 주어지면 가상 Host 헤더에서 원 서버의 이름과 포트 번호를 알아내야 한다.
- 부분 URI이지만 가상 Host 헤더가 없다면
  - 대리 프락시라면 프락시에서 원 서버의 주소와 포트번호를 알아낸다.
  - 이전에 어떤 인터셉트 프락시가 가로챘던 트래픽을 받았다면, 그 프락시의 원 서버의 주소와 포트번호를 알아낸다.
  - 모두 실패했다면 반드시 에러 메세지를 반환한다.

### 5.6. 전송 중 URI 변경
- 프락시 서버는 요청 URI의 변경에 신경을 써야하는데, 사소한 URI 변경에도 다운스트림 서버와 상호운용성 문제를 일으킬 수 있기 때문이다. 
- HTTP 명세는 일반적인 인터셉트 프락시가 URI를 전달할 때 절대 경로를 고쳐쓰는 것을 금지한다.


### 5.6. URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)
- 브라우저는 프락시의 존재 여부에 따라 요청 URI를 다르게 분석한다.
- 프락시가 없다면 사용자가 타이핑한 URI를 가지고 그에 대응하는 IP 주소를 찾는다.
- 만약 호스트명이 발견되면 그에 대응하는 IP 주소들을 연결에 성공할 때까지 시도한다.
- 호스트명이 발견되지 않는다면 브라우저는 사용자가 호스트명의 짧은 약어를 타이핑한 것을 보고 자동화된 호스트명의 '확장'을 제공하려는 시도들을 하게 된다.


### 5.7. 프락시 없는 URI 분석(URI Resolution)
- 브라우저 검색창에 호스트명을 입력한다.
- 브라우저는 DNS로 호스트를 찾고, 실패한다.
- 호스트에 기본 프로토콜과 포트를 붙인 완전한 URI로 DNS에 질의한다.
- IP를 받는다.

### 5.8. 명시적인 프락시를 사용할 때의 URI 분석
- 명시적인 프락시를 사용하면 브라우저의 URI가 프락시를 그냥 지나쳐버리기 때문에 브라우저는 확장 기능을 수행할 수 없다.

### 5.9. 인터셉트 프락시를 이용한 URI 분석

- 클라이언트 입장에서 인터셉트 프락시는 존재하지 않는 것이기 때문에 인터셉트 프락시를 사용할 때 URI 분석은 약간 달라진다.
- oreilly → 실패 → www.oreilly.com 확장 → 성공 순서로 프락시 없는 URI 분석과 거의 유사하지만, 다른 점은 죽은 서버의 IP 주소를 탐지할 수 없다.
- 브라우저는 DNS 서버로부터 받은 IP 주소들에 대해 성공할 때 까지 접속을 시도할 때 인터셉트 프락시를 사용하면 첫 번째 접속 시도는 원 서버가 아닌 프락시 서버에 의해 종료된다.
- 이 때, 이 서버는 살아있지 않았을 수도 있다.

## 6. 메시지 추적
오늘날 웹 요청이 둘 이상의 프락시를 지나는 일은 드문 일이 아니며, 웹 요청이 프락시를 지나는 일이 흔해지면서 IP 패킷의 흐름을 추적하는 것 못지않게 프락시를 넘나드는 메시지의 흐름을 춪ㄱ하고 문제점을 찾아내는 것도 팰요해졌다.

### 6.1. Via 헤더
Via 헤더 필드는 메시지가 지나는 각 중간 노드의 정보를 나열하고, 메시지가 또 다른 노드를 지날 때마다 중간 노드는 Via 목록의 끝에 반드시 추가되어야 한다.

```
Via: 1.1 proxy-62.irens-isp.net, 1.0 cache.joes-hardware.com
```

프락시는 요청을 보내기 전에 자신을 가리키는 유일한(Unique) 문자열을 Via 헤더에 삽입해야 하고, 네트워크에 라우팅 루프가 있는지 탐지하기 위해 이 문자열이 들어온 요청이 있는지 검사해야 한다.


#### Via 문법
- Via 헤더 필드는 쉼표로 구분된 경유지(waypoint)의 목록이다.
- 각 경유지는 개별 프락시 서버나 게이트웨이 홉을 나타내며 그들 중간 노드의 프로토콜과 주소에 대한 정보를 담고 있다.
- 각 Via 경유지는 프로토콜 이름, 프로토콜 버전, 노드이름, 코멘트 최대 4개의 구성요소를 담을 수 있다.
  - 프로토콜 이름(Optional, 기본은 HTTP): 중개자가 받은 프로토콜(HTTPS, FTP 등)
  - 프로토콜 버전 : 수신한 메시지의 버전(1.0 | 1.1 등)
  - 노드이름 : 중개자의 호스트와 포트 번호(포트 번호가 없다면 프로토콜의 기본 포트 번호 사사용)
  - 노드 코멘트(Optional) : 중개자 노드를 서술하는 선택적인 코멘트.

#### Via 요청과 응답 경로
요청, 응답 메시지 모두 프락시를 지나므로 둘 다 Via 헤더를 가진다. 요청과 응답은 보통 같은 TCP 커넥션을 지나므로 응답의 Via 헤더는 거의 언제나 요청의 Via 헤더와 반대다.


#### Via와 게이트웨이
몇몇 프락시는 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공한다. Via 헤더는 프로토콜 변환을 기록하므로 HTTP 애플리케이션은 프락시 연쇄에서 프로토콜 능력과 변환이 있었는지를 알아챌 수 있다.


#### Server 헤더와 Via 헤더
Server 응답 헤더 필드는 원 서버에 의해 사용되는 소프트웨어를 알려준다.

```
Server: Apache/1.3.14 (Unix) PHP/4.0.4
Server: Netscape-Enterprise/4.1
Server: Microsoft-IIS/5.0
```

응답 메시지가 프락시를 통과할 때, 프락시는 Server 헤더를 수정해서는 안되며, 대신 프락시는 Via 항목을 추가해야 한다.


#### Via가 개인정보 보호와 보안에 미치는 영향
Via 문자열 안에 정확한 호스트 명이 들어가기를 원하지 않는 몇 가지 경우가 있다. 보통 명시적으로 이 동작이 켜져있지 않은 이상 프락시 서버가 네트워크 방화벽의 일부인 경우 프락시는 방화벽 뒤에 숨어있는 호스트의 이름과 포트를 전달해서는 안된다.

방화벽 뒤의 네트워크 아키텍처 정보가 악의적인 집단에 의해 이용될 수 있기 때문이다.프락시는 정렬된 일련의 Via 경유지 항목들을 하나로 합칠 수 있는데, 수신된 프로토콜 값들이 동일해야 한다.

```
// from
via: 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com

// to
via: 1.0 foo, 1.1 concealed-stuff
```

### 6.2. TRACE 메서드
프락시 서버는 메시지가 전달될 때 헤더가 추가되거나, 변경, 삭제될 수 있으며, 본문이 다른 형식으로 변환되는 등 메시지를 바꿀 수 있다.

HTTP/1.1의 TRACE 메서드는 요청 메시지를 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적할 수 있도록 해줘서 프락시 흐름을 디버깅하는데 매우 유용하다.


#### Max-Forwards
일반적으로 TRACE 메서드는 프락시들이 몇 개나 있든 신경쓰지 않고 목적지 서버로의 모든 경로를 확인한다. 이 때, 전달되는 메시지가 무한 루프에 빠지지 않는지 프락시 연쇄를 테스트하거나 연쇄 중간의 특정 프락시 서버들의 효과를 체크하기 위해 Max-Forwards 헤더를 사용할 수 있다.
- Max-Forwards 값이 0이라면 더 이상 TRACE 메시지를 전달하지 않는다.
- Max-Forwards 값이 1 이상이라면 반드시 1 감소된 값으로 갱신한 후 메시지를 전달한다.


## 7. 프락시 인증
프락시는 접근 제어 장치로서 제공될 수 있다. HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 메커니즘을 정의하고 있다.

- 제한된 콘텐츠에 대한 요청이 프락시 서버에 도착했을 때, 프락시 서버는 접근 자격을 요구하는 407 Proxy Authorization Required 상태 코드를 어떻게 그러한 자격을 제출할 수 있는지 설명해주는 Proxy-Authenticate 헤더 필드와 함께 반환할 수 있다.
- 클라이언트는 407 응답을 받게 되면, 로컬 데이터베이스를 확인하거나 사용자에게 물어보는 방법을 통해 요구되는 자격을 수집한다.
- 자격을 획득하면, 클라이언트는 요구되는 자격을 Proxy-Authorization 헤더 필드에 담아서 요청을 다시 보낸다.
- 자격이 유효하다면, 프락시는 원 요청을 연쇄를 따라 통과시키고, 유효하지 않다면 407 응답을 보낸다.


## 8. 프락시 상호 운용성
클라이언트, 서버, 프락시는 HTTP 명세의 여러 버전에 대해 여러 벤더에 의해 만들어진다.

### 8.1. 지원하지 않는 헤더와 메서드 다루기
- 프락시 서버는 넘어오는 헤더 필드들을 모두 이해하지 못할 수도 있다.
- 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 하고, 같은 이름의 헤더 필드가 여러 개 있는 경우 그들의 상대적인 순서도 반드시 유지해야 한다.
- 지원하지 않는 메서드를 통과시킬 수 없는 프락시는 오늘날 대부분의 네트워크에서 살아남지 못한다.


### 8.2. OPTIONS: 어떤 기능을 지원하는지 알아보기
HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트(또는 프락시)가 알아볼 수 있게 해준다. 서로 다른 기능 수준의 서버와 프락시가 더 쉽게 상호작용할 수 있도록 클라이언트는 OPTIONS를 이용해 서버의 능력을 먼저 알아낼 수 있다.

```
OPTIONS * HTTP/1.1
```

만약 OPTIONS 요청의 URI가 별표(*)라면 서버 전체의 능력에 대해 묻는 것이 된다.

```
OPTIONS http://www.joes-hardware.com/index.html HTTP/1.1
static HTML file wouldn't accept a POST method.
```
만약 OPTIONS 요청의 URI가 실제 리소스라면 특정 리소스에 대해 가능한 기능들을 묻는 것이다.


### 8.3. Allow 헤더
Allow 엔터티 헤더 필드는 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드(요청하는 URI가 *인 경우)를 열거한다.

```
Allow: GET, HEAD, PUT
```
Allow 헤더는 새 리소스가 지원했으면 하는 메서드를 추천하기 위해 요청 헤더로 사용될 수 있지만, 모두 지원해야할 의무는 없으며, 그 요청에 대한 응답에는 실제로 지원하는 메서드들을 열거하는 Allow 헤더를 포함시켜야 한다.




