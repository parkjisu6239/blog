# [HTTP 완벽 가이드] Chap3. HTTP 메시지

## TL;DR
- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 1. 메시지의 흐름
- http 메시지는 애플리케이션 간에 주고받은 데이터의 블록들이다.
- 인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미하는 용어다.

### 1.1. 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- http는 인바운드, 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 인바운드 : 클라이언트 -> 서버
- 아웃바운드 : 서버 -> 클라이언트

### 1.2. 다운스트림으로 흐르는 메시지
- http는 요청, 응답에 관계 없이 다운스트림으로 흐른다.
- 메시지의 발송하즌 수신자의 업스트림이다.

## 2. 메시지의 각 부분
- http 메시지는 단순한, 데이터의 구조화된 블록이다.
- 각 메시지는 클라이언트로부터 요청이나 서버로부터 응답 증 하나를 포함한다.
- 메시지는 시작줄, 헤더블록, 본문으로 이루어진다.
  - 시작줄 : 어떤 메시지인지 서술
  - 헤더 : 속성
  - 본문 : 데이터
- 시작줄과 헤더는 줄단위로 분리된 아스키 문자열이다.
- 각 줄은 캐리지리턴(ASCII 13), 개행문자로 구성된 두 글자의 줄 바꿈 문자열로 끊난다.
- 본문은 텍스트나 이진 데이터를 포함할 수도 있고, 비어있을 수도 있다.

### 2.1. 메시지 문법
- http 메시지는 요청/응답 메시지로 분류된다.
- 요청 메시지의 형식 
  ```
  <메서드> <요청 URL> <버전>
  <헤더>

  <엔터티 본문>
  ```
- 응답 메시지의 형식
  ```
  <버전> <상태 코드 사유 구절>
  <헤더>
  <엔티티 본문>>
  ```


| 메시지 구성 요소 | 설명 |
|-----|-----|
| 매서드 | 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작으로, `GET`, `POST`, `HEAD` 와 같이 한 단어로 되어 있다. |
| 요청 URL | 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성 요소이다. 서버는 URL 에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주한다. |
|버전 | http 에서 사용중인 버전으로 `HTTP/<메이저>.<마이너>` 형식이다. 메이저와 마이너 모두 정수이다. |
|상태코드| 요청중 무슨일이 일어났는지를 설명하는 세자리의 숫자이다. 각 코드의 첫번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타낸다. |
| 사유 구절 | 숫자로된 상태코드를 설명하는 짧은 문구로 상태 코드와 줄바꿈 문자 사이에 있다. |
|헤더들| 이름, 콜론(:), 공백, 값, CRLF(빈줄) 가 순서대로 나타나는 0개 이상의 헤더들. 빈줄로 끝난다. 몇몇 버전의 http는 요청이나 응답에 어떤 특정 헤더가포함되어야만 유효한 것으로 간주한다. |
|엔터티 본문 | 임의의 데이터 블록을 포함한다. 없는 경우도 있다. |

![message](https://miro.medium.com/max/1400/1*IqqMQt5-yawg0ucQ5n9qIw.png)

### 2.2. 시작줄
- 모든 http 메시지는 시작줄로 시작한다. 
- req : 무엇을 해야하는지 의미
- res : 무슨일이 일어났는지 의미

#### 요청줄
- 서버에서 어떤 동작이 일어나야하는지 설명 해주는 매서드
- 동작에 대한 대상(URL)
- http 버전

#### 응답줄
- http 버전
- 상태 코드
- 사유구절

#### 메서드
- 서버에게 무엇을 해야하는지 말해주는 역할
- 메서드에 따라 본문이 있는 경우도 있고, 없는 경우도 있다.
- 자세한 내용은 [MDN http method](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods) 참고

|메서드|설명|본문 여부|
|---|---|---|
|GET| 서버에서 리소스를 가져온다 | N |
|HEAD| GET 과 동일하지만, 헤더만 가져온다 | N |
|POST | 리소스에 언티티를 제출할 때 쓰인다. 처리할 데이터를 보낸다. | Y|
|PUT | 서버에 요청 메시지의 본문을 저장한다. | Y|
|PATCH| 리소스의 일부를 수정한다. | Y|
|CONNECT| 리소스로 식별되는 서버로의 터널을 맺는다. | N |
|TRACE| 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | N|
|OPTIONS| 어떤 메서드를 수행할 수 있는지 확인한다. | N |
|DELETE| 특정 리소스를 삭제한다. | N |

모든 서버가 위 메서드를 모두 구현한 것은 아니며, 이것들 외에도 서버는 그들만의 메서드를 추가로 구현할 수 있다. 이것을 `확장 메서드` 라고 한다.

#### 상태 코드
- 모든 상태 코드 설명은 [MDN http status code](https://developer.mozilla.org/ko/docs/Web/HTTP/Status) 참고
- 서버가 클라이언트의 요청 처리중에 무슨일이 있었는지 알려준다.

|전체 범위 | 정의된 범위 | 분류 |
|---|---|---|
|100 ~ 199 | 100 ~ 101 | 정보 |
|200 ~ 299 | 200 ~ 206 | 성공 |
|300 ~ 399 | 300 ~ 305 | 리다이렉션 |
|400 ~ 499 | 400 ~ 415 | 클라이언트 에러 |
|500 ~ 599 | 500 ~ 505 | 서버 에러 |

500번대까지 있지만, 실제로 사용하는 코드는 많지 않으며 http 가 진화하면서 더 많은 상태코드가 정의될 것이다. 만약 현재 위 코드 외에 다른 코드를 받는다면, 프로토콜 확장으로 직접 정의했을 가능성이 있다.

#### 사유구절
- 응답 시작줄의 마지막 구성 요소이다.
- 상태코드와 대응된다.

#### 버전 번호
- `HTTP/<메이저>.<마이너>` 형식으로 요청, 응답 양쪽에 모두 기술된다.
- 프로토콜 버전을 의미하며, 애플리케이션들에게 대화 상대의 능력과 메시지 형식에 대한 단서를 제공해준다.
- 일부 버전에서는 사용가능한 기능이, 다른 버전에서는 그렇지 않은 경우가 있기 떄문이다.
- 애플리케이션이 지원하는 가장 높은 버전을 가리킨다.

### 2.3. 헤더
- 요청과 응답 메시지에 추가 정보를 더한다.
- 기본적으로 이름/값 쌍의 목록이다.
- 더 많은 내용 [MDN http headers](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers)

|헤더분류 | 정보 |
|---|---|
| 일반 헤더 | 요청, 응답 양쪽 모두애 나타날 수 있음|
|요청 헤더 | 요청에 대한 부가 정보 제공|
| 응답 헤더 | 응답에 대한 부가 정보 제공 |
| 엔티티 헤더 | 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술 |
|확장 헤더 | 명세에 정의되지 않은 새로운 헤더 |

각 헤더는 간단한 문법을 가진다. 이름, 쉼표, 공백(없어도 됨), 필드값, CRLF 가 순서대로 온다.

![headers](https://images.velog.io/images/sanspareilsmyn/post/9ac06f51-7cf6-4ef6-827d-99e49d4265e0/image.png)

#### 헤더를 여러 줄로 나누기
- 긴 헤더줄을 여러줄로 쪼개서 읽기 좋게 만들수 있다.
- 이떄, 추가줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야한다.

### 2.4. 엔터티 본문
- 선택적이며, 메시지의 화물이라고 할 수 있다.
- 이미지, 비디오, html 문서, ... 를 실어나른다.

### 2.5. 버전 0.9 메시지
- 0.9 버전은 프로토콜의 초기 버전으로, 지금의 버전보다 훨씬 단순하다.
- 요청은 메서드, URL 밖에 없었고 응답은 엔터티밖에 없었다.
- 이 엄청난 단순함 때문에, 여러 상황에 대응하기 어려웠고 이후로 여러 값들이 추가 되었다.

## 3. 메서드
- 모든 서버가 모든 메서드를 구현하지는 않는다.
- http 1.1 이라면 GET, HEAD 만 구현해도 된다.
- 메서드는 대부분 제한적이다.(PUT, DELETE는 특히 더)

### 3.1. 안전한 메서드(Safe Method)
- GET, HEAD 메서드가 있다.
- 이 둘은 http 요청의 결과로 서버에 어떠한 작용도 없음을 의미한다.
- 서버 리소스를 조작하지 않고, 그 리소스를 달라고 요청할 뿐이다.
- [멱등성](https://developer.mozilla.org/ko/docs/Glossary/Idempotent)을 가진다.

### 3.2. GET
- 가장 흔히 쓰는 메서드로, 서버에게 리소스를 달라고 요청한다.

![get](https://t1.daumcdn.net/cfile/tistory/21282E3B554A0A1B2C)

### 3.3. HEAD
- GET 과 마찬가지로 리소스를 요청하지만, 서버는 응답으로 헤더만을 돌려준다.
- 엔터티 본문은 반환되지 않는다.
- 리소스 없이 헤더만 조사할 수 있게 하여 리소스의 타입이나, 리소스의 존재 여부(상태 코드로 확인) 을 알 수 있다.
- 서버를 구성할 때 GET, HEAD의 헤더가 정확하게 일치함을 보장해야한다.

### 3.4. PUT
- GET이 문서를 읽어들이는데 반해, PUT은 서버에 문서를 쓴다.
- 기본적인 의미로는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새문서를 만들거나, 이미 URL이 존재한다면 본문을 교체하는 것을 의미한다.
- 서버 콘텐츠를 변경하는 작업이므로, 일반적으로 인가된 사용자인지 확인하는 작업이 필요하다.

### 3.5. POST
- 서버에 입력 데이터를 전송하기 위해 설계 되었다.
- HTML form 을 지원하기 위해 흔히 사용된다.
- form 이 아니더라도, 의미상 입력값을 전달할 때 사용한다.

<details>
<summary>PUT vs POST</summary>
<p>
둘의 차이는 멱등성으로, PUT은 한번을 보내든 여러번을 보내든 같은 효과를 보인다. 즉, 부수 효과가 없다. 하지만 POST는 그렇지 않다.
</p>
</details>

### 3.6. TRACE
- 클라이언트가 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이등의 애플리케이션을 통과할 수 있다.
- 이들에게는 원래의 http 요청을 수정할 수 있는 기회가 있다.
- TRACE는 메서드가 최종적으로 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
- TRACE 요청은 목적지 서버에서 `루프백(loopback)` 진단을 시작한다.
- 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답으로 되돌려준다.
- 클라이언트 ~ 서버 사이의 모든 애플리케이션들의 요청/응답 연쇄를 따라가면서 메시지가 어떻게 변화되었는지 히스토리를 볼 수 있다.
- 주로 진단을 위해 사용되며, 프락시나 다른 애플리케이션이 요청에 어떤 영향을 미치는지 확인해보고자 할 때 좋은 도구다.
  - 하지만 TRACE는 중간 애플리케이션이 여러 다른 종류의 요청을 일관되게 다룬다고 가정하는 문제가 있다.
  - 많은 http 애플리케이션은 메서드에 따라 다르게 동작한다. 그런데 TRACE는 메서드를 구별하는 메커니즘을 제공하진 않는다.
  - TRACE를 어떻게 처리할 것인지에 대해서는 중간 애플리케이션이 결정을 내린다.

<details>
<summary>Try</summary>

cmd 에 아래 명령어를 입력하면 내용을 볼 수 있는데, google은 trace 메서드를 막아놨다. (브라우저에서 요청한게 아니라 그럴 수도 있고)
```
curl -v -X TRACE https://www.google.com
```
~~OPTIONS는 거절됨,,~~

</details>

### 3.7. OPTIONS
- 웹 서베에게 가능한 메서드를 물어본다.

### 3.8. DELETE
- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
- 실제로 삭제되는 것을 보장하지는 못한다. 인가되지 않은 사용자의 요청이나 이미 존재하지 않거나, 지울 수 없는 리소스를 삭제하지 않는다.
- 응답으로 결과로 삭제 여부등을 알려준다.

### 3.9. 확장 메서드
- http는 필요에 따라 확장해도 문제가 없도록 설계되어서, 새로운 기능을 추가해도 과거에 구현된 소프트웨어들의 오작동을 유발하지 않는다.
- 확장메서드는 http/1.1 에 정의되지 않은 메서드로, 서버의 개발자들이 개별적으로 구현한다.
- 확장 메서드의 대표적인 예는 다음과 같다.

|메서드|설명|
|---|---|
|LOCK|리소스를 잠글 수 있게 한다. 동시편접을 막는 등|
|MKCOL|문서를 생성할 수 있게 한다|
|COPY|리소스 복사|
|MOVE|리소스 이동|

- 직접 확장 메서드를 만들거나, 확장 메서드를 가지는 애플리케이션과 통신하는 경우 http가 이해할 수 없는 경우가 있다.
- 프락시는 종단간의 행위를 망가뜨리지 않는한, 알려지지 않은 메서드라도 다운스트림으로 서버에 전달하려고 시도한다.
- 그렇지 않다면 프락시는 501 Not Implement 상태 코드로 응답해야한다.
- 확장 메서드를 다룰 때는 `엄격하게 보내고 관대하게 받아들여라` 라는 오랜 규칙을 따르는 것이 좋다.

## 4. 상태코드
http 상태코드는 크게 다섯가지로 나뉜다. 상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다. http/1.1 에서는 사유구절을 포함시켰다.

### 4.1. 100 - 199 정보성 상태 코드
- http/1.1 에서 도입되었다.
- 비교적 새로운 것으로, 복잡함을 감수할만한 가치가 있는지에 대해 논란이 되고 있다.

|상태코드|사유구절|의미|
|---|---|---|
|100|Continue|요청의 시작부분 일부가 받아들여졌으며, 클라이언트는 나머지를 이어서 보내야함을 의미. 이것을 보낸 후, 서버는 반드시요청을 받아 응답해야한다.|
|101|Switching Protocol|클라이언트가 Upgrade 헤더에 나열한 것중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.|

100 Continue 는 클라이언트가 서버에 엔터티 본문을 전송하기 전에 서버가 이를 받아들일 것인지 확인하려고 할떄, 그 작업을 최적화하기 위한 의도로 도입되었는데, 이는 프로그래머를 혼란스럽게 하는 경향이 있다.

#### 클라이언트와 100 Continue
만약 클라이언트가 엔터티를 서버에 보내려고 할때, 그 전에 100 응답을 기다리겠다면, 클라이언트는 값을 100-continue 로 하는 Expect 요청을 헤더에 보낼 필요가 있다.

만약 클라이언트가 엔터티를 보내지 않으려한다면, 위의 헤더를 보내지 않아야 서버가 헷갈리지 않는다.

100-continue는 서버가 받지 않을 큰 엔티티를 보내지 않게 하여 최적화를 하려는 목적으로만 사용해야 한다.

100 Continue는 초창기의 혼란 떄문에 Expect 헤더를 보내고, 서버의 100 응답을 막연히 기다리는게 아니라, 타임아웃 후에는 그냥 엔티티를 보내야 한다. 그러면 결국 최적화가 되지 않는다. 또, 예상치 못한 100 응답에 대비해야하기도 한다.

#### 서버와 100 Continue
서버가 Expect 헤더가 담긴 요청을 받는다면, 100 또는 에러 코드로 답해야한다. 서버는 100 응답을 원하지 않는 클라이언트에게 100 응답을 보내서는 안된다. 하지만 일부 잘못 만들어진 서버는 요청한 적도 없는 100응답을 주곤한다.

서버가 100응답을 보내기전에 엔터티 일부 혹은 전체를 수신했다면, 100을 보낼 필요가 없다. 그러나 서버가 요청을 끝까지 다 읽은 후에는 그 요청에 대한 최종 응답을 보내야 한다.

만약 서버가 100응답을 받을것을 의도한 요청을 받고 난 상태에서 엔터티 본문을 읽기전에 요청을 끝내기로 결정했다면, 서버는 그냥 응답을 보내고 연결을 닫아서는 안된다. 클라이언트가 응답을 받을 수 없게 되기 때문이다.

#### 프락시와 100 Continue
클라이언트로부터 100 응답을 의도한 요청을 받은 프락시는 몇가지 해야할 일이있다. 만약 다음 홉 서버가 http/1.1 을 따르거나, 혹은 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함시켜서 요청을 다음으로 전달해야한다. 다음 홉 버전이 이를 지원하지 않으면 417 Expectation Faild 에러로 응답해야한다. 

만약 프락시가 구버전을 따르는 클라이언트를 대신하여 Expect 헤더와 100-continue 값을 요청에 포함시키기로 했다면, 프락시는 100 응답을 클라이언트에 전달해서는 안된다. 왜냐면 클라이언트는 구버전이라 100응답을 어떻게 처리할지 모른다.

프락시가 다음 홉 셔버들에 대한 상태 몇가지와 그들이 지원하는 http 버전을 기억해둔다면, 100-continue 응답을 기대한 요청을 더 잘 다룰 수 있게 되어 프락시에 이득이된다.

### 4.2. 200 - 299 성공 상태 코드

|상태코드|사유구절|의미|
|---|---|---|
|200 |OK| 요청 성공, 엔티티 본문은 리소스를 포함한다.|
|201| Created| PUT, POST 요청으로 서버에 새로운 리소스가 정상적으로 생성되었음을 의미. 응답은 생성된 리소스에 대한 Location 헤더, URL 등|
|202| Accepted| 요청이 받아들여졌다. 실제로 수행되었는지는 알수없음|
|203| Non-Authoritative Information|이 응답 코드는 돌려받은 메타 정보 세트가 오리진 서버의 것과 일치하지 않지만 로컬이나 서드 파티 복사본에서 모아졌음을 의미합니다. 서버에서 가져왔다면 200이었을 응답인 경우에 사용됨|
|204 |No Content|요청에 대해서 보내줄 수 있는 콘텐츠가 없지만, 헤더는 의미있을 수 있습니다. 응답 메시지는 헤더와 상태줄은 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹브라우저를 새문서로 이동시키지 않고 갱신할때(새로고침) 사용한다.|
|205| Reset Content|주로 브라우저를 위해 사용되는 코드. 현재 페이지에 있는 html 폼의 모든 값을 비우라고 말한다.|
|206| Partial Content|리소스의 일부분 요청이 성공했다. range header 등을 사용한 경우. 206 응답은 Content-Range 와 Date 헤더를 반드시 포함해야하며, Etag와 Content-length 중 하나의 헤더도 반드시 포함해야한다.|

### 4.3. 300 - 399 리다이렉션 상태 코드
클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.

만약 리소스가 옮겨졌다면, 리소스가 옮겨졌으면 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 (선택적으로) Location 헤더를 보낼 수 있다. 이떄 리다이렉션은 브라우저가 알아서 위치로 이동한다.

리다이렉션 상태 코드 중 몇몇은 리소스에 대한 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다. 이때 특별한 헤드인 `If-Modified-Since` 헤더를 전송한다. 그 문서가 그 날짜 이후에 변한 것이 없다면, 서버 콘텐츠 대신 304로 답한다.

일반적으로 HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.

|상태 코드	|사유 구절	|의미|
|---|---|----|
|300	|Multiple Choices|	클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청할 경우, 그 리소스의 목록과 함께 반환한다. 사용자는 목록에서 원하는 하나를 선택할 수 있다.|
|301	|Moved Permanently|	요청한 URL이 옮겨졌을 때 사용함. 응답에 Location 헤더에 현재 리소스의 URL을 포함해야 한다.|
|302	|Found|	301 상태 코드와 같다. 그러나 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다.|
|303	|See Other|	클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말할 때 사용한다. 새 URL은 응답 메시지의 Location 헤더에 들어있다.|
|304|	Not Modified|	리소스가 수정되지 않았음을 의미한다. 엔터티 본문을 가져서는 안 된다.|
|305|	Use Proxy|리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다. 프락시 위치는 Location 헤더를 통해 주어진다. 클라이언트는 이 응답을 특정 리소스에 대한 것이라고만 해석한다.|
|306|	(사용되지 않음)|	사용되지 않는다.|
|307|	Temporary Redirect | 301 코드와 비슷하다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다.|

표에서 302, 303, 307 상태코드는 일부 중복된 내용이 있다. http/1.0 클라이언트가 POST 요청을 보내고 302 리다이렉트 상태 코드가 담긴 응답을 받으면, 클라이언트는 Location 헤더에 들어있는 리다이렉트 URL을 GET 요청으로 따라갈 것이다.
http/1.1은 리다이렉션을 위한 코드로 303을 쓴다.
둘의 혼란을 막기 위해 http/1.1은 일시적인 리다이렉트 상태를 302 대신 307로 쓰라고 한다. 302는 http/1.0을 위해 남겨둔다.

결국 서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이렉트 상태코드를 선택하기 위해 클라이언트의 http 버전을 검사할 필요가 있다.

### 4.4. 400 - 499 클라이언트 에러 상태
클라이언트가 잘못된 요청 메시지를 보내는 경우 서버는 다음과 같은 응답을 보낸다.

|상태 코드|	사유 구절|	의미|
|---|----|----|
|400	|Bad Request|	클라이언트가 잘못된 요청을 보냈다고 말해줌.|
|401	|Unauthorized|	리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 반환함.|
|403	|Forbidden|	요청이 서버에 의해 거부되었음. 거부된 이유는 본문에 포함시키기도 하지만, 이유를 숨길떄 많이 사용함|
|404	|Not Found|	요청한 URL을 찾을 수 없음.|
|405	|Method Not Allowed|	지원하지 않는 메서드로 요청됨.|
|406	|Not Acceptable|주어진 URL 에 대한 리소스중 클라이언트가 받아들일 수 있는 것이 없을떄 사용됨|
|407	|Proxy Authentication Required|	401과 같지만, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다.|
|408	|Request Timeout|	클라이언트 요청을 완수하는 시간이 오래 걸리는 경우, 이 상태 코드로 응답하고 연결을 끊을 수 있음.|
|409	|Conflict|	요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용함.|
|410	|Gone|	404와 비슷하나, 서버가 한 때 그 리소스를 갖고 있었다는 점이 다름.|
|411	|Length Required|	요청 메시지에 Content-Length 헤더가 있을 것을 요구|
|412	|Precondition Failed|	조건부 요청(Expect 헤더 포함)중 하나가 실패한 경우 사용|
|413	|Request Entity Too Large|	서버가 처리할 수 있는 한계를 넘은 요청을 보낸 경우|
|414	|Request URI Too Long|처리 가능한 URL 길이를 넘은 경우|
|415	|Unsupported Media Type|	서버가 지원하지 않은 언테티를 보낸 경우|
|416	|Requested Range Not Satisfiable|	리소스의 범위가 잘못된 경우|
|417	|Expectation Failed|	Expect 요청 헤더에 서버가 만족시킬 수 없는 조건이 있는 경우|

### 4.5. 500 - 599 서버 에러 상태
클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다.

|상태 코드|	사유 구절|	의미|
|---|----|----|
|500	|Internal Server Error|	서버가 요청을 처리할 수 없는 에러를 만났을 때 사용함.|
|501	|Not Implemented|	클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용함.|
|502	|Bad Gateway|	프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용함.|
|503	|Service Unavailable|	현재는 서버가 요청을 처리해줄 수 없지만 나중에는 가능함.|
|504	|Gateway Timeout|	408과 비슷하지만, 다른 서버에 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다름.|
|505	|HTTP Version Not Supported	|서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용함.|

## 5. 헤더
헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 사용한다. 표준 http 헤더와 http/1.1 에 정의되지 않은 몇몇 헤더에 대해 알아보자.
헤더에는 특정 종류의 메시지에서만 사용할 수 있는 헤더와, 일반적으로 사용하는 헤더, 응답/요청 모두에서 정보를 제공하는 헤더가 있다. 헤더는 크게 다섯가지로 분류된다.

### 5.1. 일반 헤더 (General Headers)
- 메시지에 대한 아주 기본적인 정보를 제공한다.
```
Connection: keep-alive
Date: Fri Jul 29 2022 22:45:23 GMT
Transfer-Encoding: gzip, chunked
Via: HTTP/1.1 GWA
```

|헤더|	설명|
|---|----|
|Connection| 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다. 전송된 값이 keep-alive일 경우, 연결은 지속적이며 닫히지 않으므로 동일한 서버에 대한 후속 요청이 수행될 수 있다. close, keep-alive |
|Date| 메세지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다.|
|MIME-Version| 발송자가 사용한 MIME의 버전을 알려준다.|
|Trailer chunked transfer| 인코딩된 메세지의 끝 부분에 위치한 헤더들의 목록을 나열한다.|
|Transfer-Encoding| 수신자에게 안전한 전송을 위해 메세지에 어떤 인코딩이 적용되었는지 말해준다.|
|chunked, compress, deflate, gzip, identity|
|Upgrade| 발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 알려준다.|
|Via| 이 메세지가 어떤 중개자를 거쳐 왔는지 보여준다.|

#### 일반 캐시 헤더
- http/1.0은 매번 원서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했다.
- http는 매우 풍부한 캐시 매개변수의 집합을 가지고 있다.
```
Cache-Control: public, max-age=31536000
Pragma: no-cache
```

- Cache-Control: 메세지와 함께 캐시 지시자를 전달하기 위해 사용한다.
  - max-age={seconds}, max-stale[={seconds}], min-fresh={seconds}, no-cache, no-store, no-transform, only-if-cached, must-revalidate, no-cache, no-store, no-transform, public, private, proxy-revalidate, s-maxage={seconds}, immutable, stale-while-revalidate={seconds}, stale-if-error={seconds},
- Pragma: 메세지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않는다. (HTTP/1.0)


### 5.2. 요청 헤더 (Request Headers)
요청 메시지에서만 의미를 갖는 헤더. 클라이언트 정보, 선호, 능력에 대한 정보를 보여준다.

#### Accept 관련 헤더
```
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1
Accept-Encoding: gzip, compress, br
Accept-Language: de-CH
TE: gzip
```

- 클라이언트는 Accept 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있다.
- 서버는 클라이언트가 사용할 수도 없는 것을 전송하는데 시간과 대역폭을 낭비하지 않을 수 있다.
- Accept: 서버에게 서버가 보내도 되는 콘텐츠 타입을 MIME 타입를 말해준다.
- Accept-Charset: 서버에게 서버가 보내도 되는 문자집합을 말해준다.
- Accept-Encoding: 서버에게 서버가 보내도 되는 인코딩을 말해준다.
  - gzip, compress, deflate, br, identity
- Accept-Language: 서버에게 서버가 보내도 되는 언어를 말해준다.
- TE: 서버에게 서버가 보내도 되는 확장전송 코딩을 말해준다. (Transfer-Encoding)
  - compress, deflate, gzip, trailers

#### 조건부 요청 헤더
- 클라는 요청에 몇몇 제약을 넣기도 한다.
- 클라는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다.

```
Expect: 100-continue
If-Match: "bfc13a64729c4290ef5b2c2730249c88ca92d82d"
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
If-None-Match: "bfc13a64729c4290ef5b2c2730249c88ca92d82d"
If-Range: Wed, 21 Oct 2015 07:28:00 GMT
If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT
Range: bytes=0-499, -500
```

- Expect: 클라가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다.
- If-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져온다.
  - {etag_value}
- If-Modified-Since: 주어진 날짜 이후에 리소스가 변경되지 않는다면 요청을 제한한다.
- If-None-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져온다.
- If-Range: 문서의 특정 범위에 대한 요청을 할 수 있게 해준다.
  - {date}, {etag}
- If-Unmodified-Since: 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다.
- Range: 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청한다.
  - {unit}={range-start}-{range-end}, {range-start}-{range-end}
  - ex. bytes=200-1000

#### 요청 보안 헤더
- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다.
- 요청하는 클라가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써, 트랜잭션을 약간 더 안전하게 만들고자 한다.

```
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1;
```

- Authorization: 클라가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다.
  - {type} {credentials}
  - 예시) Basic YWxhZGRpbjpvcGVuc2VzYW1l
- Cookie: 클라가 서버에게 토큰을 전달할 때 사용한다. 진짜 보안헤더는 아니지만, 보안에 영향을 줄 수 있다는 것은 확실하다.
  - {name}={value}; {name2}={value2};
- Cookie2: 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용한다.

#### 프락시 요청 헤더
```
Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

- Max-Forwards: 요청이 원서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수.
  - 관련) TRACE 메서드와 함께 사용된다.
- Proxy-Authorization: Authorization과 같으나 프락시에서 인증을 할 때 쓰인다.
  - {type} {credentials}
- Proxy-Connection: Connection과 같으나 프락시에서 연결을 맺을 때 쓰인다.

### 5.3. 응답 헤더 (Response Headers)
클라이언트가 응답을 더 잘 다루고 추후 더 나은 요청을 할 수 있게 도와준다. 누가 응답을 보내는지, 응답자의 능력, 응답에 대한 특별한 설명을 제공한다.

```
Age: 24
Retry-After: Wed, 21 Oct 2015 07:28:00 GMT
Server: Apache/2.4.1 (Unix)
Warning: 112 - "cache down" "Wed, 21 Oct 2015 07:28:00 GMT"
```

- Age: 응답이 얼마나 오래되었는지
  - {delta-seconds}
- Public: 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록
- Retry-After: 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시간
  - {http-date}, {delay-seconds}
- Server: 서버 어플리케이션의 이름과 버전
  - {product}
- Title: HTML 문서에서 주어진 것과 같은 제목
- Warning: 사유 구절에 있는 것보다 더 자세한 경고 메세지
  - {warn-code} {warn-agent} {warn-text} [{warn-date}]
  - 예시) Warning: 110 anderson/1.3.37 “Response is stale”

#### 협상 헤더
서버에 프랑스어나 독일어로 번역된 HTML 문서가 있는 경우와 같이 여러 가지 표현이 가능한 상황이라면,
HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있도록 지원한다.
```
Accept-Ranges: bytes
Vary: User-Agent
```

- Accept-Ranges: 서버에게 서버가 보내도 되는 언어를 말해준다.
- Vary: 서버가 확인해 보아야 하고, 그렇기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록

#### 응답 보안 헤더
기본적인 인증 요구 헤더들이다.
```
Proxy-Authenticate: Basic realm="Access to the internal site"
Set-Cookie: sessionid=38afes7a8; HttpOnly; Path=/
WWW-Authenticate: Basic
```

- Proxy-Authenticate: 프락시에서 클라로 보낸 인증요구의 목록
- Set-Cookie: 진짜 보안 헤더는 아니지만, 보안에 영향은 줄 수 있다. 서버가 클라를 인증할 수 있도록 클라 측에 토큰을 설정하기 위해 사용한다.
  - {cookie-name}={cookie-value}
  - {cookie-name}={cookie-value}; Expires={date}
  - {cookie-name}={cookie-value}; Max-Age={non-zero-digit}
  - {cookie-name}={cookie-value}; Domain={domain-value}
  - {cookie-name}={cookie-value}; Path={path-value}
  - {cookie-name}={cookie-value}; Secure
  - {cookie-name}={cookie-value}; HttpOnly
  - {cookie-name}={cookie-value}; SameSite=Strict
  - {cookie-name}={cookie-value}; SameSite=Lax
  - {cookie-name}={cookie-value}; SameSite=None
- Set-Cookie2: Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키.
- WWW-Authenticate: 서버에서 클라로 보낸 인증요구의 목록
  - {type} realm={realm}
  - 예시) Basic realm=”Access to the staging site”

### 5.4. 엔터티 헤더 (Entity Headers)
엔터티 본문의 헤더로, 엔터티와 그것의 내용물(개체의 타입, 메서드 등)에 대한 광범위한 정보 제공한다.

```
Allow: GET, POST, HEAD
Location: /index.html
```

- Allow: 이 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열한다.
  - 예시) Allow: GET, POST, HEAD
- Location: 클라에게 엔터티가 실제로 어디에 위치하고 있는지 말해준다. 수신자에게 리소스에 대한 (아마도 새로운) 위치 URL을 알려줄 때 사용한다.
  - 관련) 리다이렉션 상태코드 (300번대)

> Location과 Content-Location는 다르다.
> Location가 리다이렉션의 대상(혹은 새롭게 만들어진 문서의 URL)을 가르키는데 반해,
> Content-Location은 더 이상의 컨텐츠 협상없이, 리소스 접근에 필요한 직접적인 URL을 가르킨다.
> Location은 응답과 연관된 헤더인데 반해, Content-Location 은 반환된 개체와 연관이 있다.
> 출처 mdn

#### 콘텐츠 헤더
엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.
콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들이다.
웹브라우저는 내용 유형을 기술한 Content-Type 헤더를 보고 그 객체를 어떻게 보여줄지 결정할 수 있다.
```
Content-Encoding: gzip
Content-Language: de-DE
Content-Location: /my-first-blog-post
Content-Range: bytes 200-1000/67589
Content-Type: text/html; charset=utf-8
Content-Disposition: form-data; name="myFile"; filename="foo.txt"
```

- Content-Base: 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL
- Content-Encoding: 본문에 적용된 어떤 인코딩
  - gzip, compress, deflate, identity, br
- Content-Language: 본문을 이해하는데 가장 적절한 자연어
  - 예시) de-DE, en-CA
- Content-Length: 본문의 길이나 크기
- Content-Location: 리소스가 실제로 어디에 위치하는지
- Content-MD5: 본문의 MD5 체크섬
- Content-Range: 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현
  - {unit} {range-start}-{range-end}/{size}
  - 예시) bytes 200-1000/67589
- Content-Type: 이 본문이 어떤 종류의 객체인지
  - {media-type};charset={value}; boundary={something}
  - 예시) text/html; charset=utf-8
  - 예시) multipart/form-data; boundary=something
- Content-Disposition: 콘텐츠가 브라우저에 인라인으로 표시될 것으로 예상되는지, 즉 웹 페이지 또는 웹 페이지의 일부로서 또는 첨부 파일로 로컬로 다운로드 및 저장될 것으로 예상되는지를 나타내는 헤더다.
- Content-Disposition: inline
- Content-Disposition: attachment
- Content-Disposition: form-data
  - ; name=”fieldName”이 덧붙여서 올 수 있다.

#### 엔터티 캐싱 헤더
일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공한다.
엔터티 캐싱 헤더는 엔터티 캐싱에 대한 정보를 제공한다.
```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Expires: Wed, 21 Oct 2015 07:28:00 GMT
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

- ETag: 이 엔터티에 대한 엔터티 태그
- Expires: 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시
- Last-Modified: 가장 최근 이 엔터티가 변경된 일시


### 5.5. 확장 헤더 (Extension Headers)
애플리케이션 개발자들에 의해 만들어졌지만, 정식 http 프로토콜에 추가되지 않은 비표준 헤더이다. http 는 확장헤더를 모르더라도 용인하고 전달해야한다.

