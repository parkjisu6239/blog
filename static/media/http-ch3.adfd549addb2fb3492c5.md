# [HTTP 완벽 가이드] Chap3. HTTP 메시지

## TL;DR
- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 1. 메시지의 흐름
- http 메시지는 애플리케이션 간에 주고받은 데이터의 블록들이다.
- 인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미하는 용어다.

### 1.1. 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- http는 인바운드, 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 인바운드 : 클라이언트 -> 서버
- 아웃바운드 : 서버 -> 클라이언트

### 1.2. 다운스트림으로 흐르는 메시지
- http는 요청, 응답에 관계 없이 다운스트림으로 흐른다.
- 메시지의 발송하즌 수신자의 업스트림이다.

## 2. 메시지의 각 부분
- http 메시지는 단순한, 데이터의 구조화된 블록이다.
- 각 메시지는 클라이언트로부터 요청이나 서버로부터 응답 증 하나를 포함한다.
- 메시지는 시작줄, 헤더블록, 본문으로 이루어진다.
  - 시작줄 : 어떤 메시지인지 서술
  - 헤더 : 속성
  - 본문 : 데이터
- 시작줄과 헤더는 줄단위로 분리된 아스키 문자열이다.
- 각 줄은 캐리지리턴(ASCII 13), 개행문자로 구성된 두 글자의 줄 바꿈 문자열로 끊난다.
- 본문은 텍스트나 이진 데이터를 포함할 수도 있고, 비어있을 수도 있다.

### 2.1. 메시지 문법
- http 메시지는 요청/응답 메시지로 분류된다.
- 요청 메시지의 형식 
  ```
  <메서드> <요청 URL> <버전>
  <헤더>

  <엔터티 본문>
  ```
- 응답 메시지의 형식
  ```
  <버전> <상태 코드 사유 구절>
  <헤더>
  <엔티티 본문>>
  ```


| 메시지 구성 요소 | 설명 |
|-----|-----|
| 매서드 | 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작으로, `GET`, `POST`, `HEAD` 와 같이 한 단어로 되어 있다. |
| 요청 URL | 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성 요소이다. 서버는 URL 에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주한다. |
|버전 | http 에서 사용중인 버전으로 `HTTP/<메이저>.<마이너>` 형식이다. 메이저와 마이너 모두 정수이다. |
|상태코드| 요청중 무슨일이 일어났는지를 설명하는 세자리의 숫자이다. 각 코드의 첫번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타낸다. |
| 사유 구절 | 숫자로된 상태코드를 설명하는 짧은 문구로 상태 코드와 줄바꿈 문자 사이에 있다. |
|헤더들| 이름, 콜론(:), 공백, 값, CRLF(빈줄) 가 순서대로 나타나는 0개 이상의 헤더들. 빈줄로 끝난다. 몇몇 버전의 http는 요청이나 응답에 어떤 특정 헤더가포함되어야만 유효한 것으로 간주한다. |
|엔터티 본문 | 임의의 데이터 블록을 포함한다. 없는 경우도 있다. |

![message](https://miro.medium.com/max/1400/1*IqqMQt5-yawg0ucQ5n9qIw.png)

### 2.2. 시작줄
- 모든 http 메시지는 시작줄로 시작한다. 
- req : 무엇을 해야하는지 의미
- res : 무슨일이 일어났는지 의미

#### 요청줄
- 서버에서 어떤 동작이 일어나야하는지 설명 해주는 매서드
- 동작에 대한 대상(URL)
- http 버전

#### 응답줄
- http 버전
- 상태 코드
- 사유구절

#### 메서드
- 서버에게 무엇을 해야하는지 말해주는 역할
- 메서드에 따라 본문이 있는 경우도 있고, 없는 경우도 있다.
- 자세한 내용은 [MDN http method](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods) 참고

|메서드|설명|본문 여부|
|---|---|---|
|GET| 서버에서 리소스를 가져온다 | N |
|HEAD| GET 과 동일하지만, 헤더만 가져온다 | N |
|POST | 리소스에 언티티를 제출할 때 쓰인다. 처리할 데이터를 보낸다. | Y|
|PUT | 서버에 요청 메시지의 본문을 저장한다. | Y|
|PATCH| 리소스의 일부를 수정한다. | Y|
|CONNECT| 리소스로 식별되는 서버로의 터널을 맺는다. | N |
|TRACE| 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | N|
|OPTIONS| 어떤 메서드를 수행할 수 있는지 확인한다. | N |
|DELETE| 특정 리소스를 삭제한다. | N |

모든 서버가 위 메서드를 모두 구현한 것은 아니며, 이것들 외에도 서버는 그들만의 메서드를 추가로 구현할 수 있다. 이것을 `확장 메서드` 라고 한다.

#### 상태 코드
- 모든 상태 코드 설명은 [MDN http status code](https://developer.mozilla.org/ko/docs/Web/HTTP/Status) 참고
- 서버가 클라이언트의 요청 처리중에 무슨일이 있었는지 알려준다.

|전체 범위 | 정의된 범위 | 분류 |
|---|---|---|
|100 ~ 199 | 100 ~ 101 | 정보 |
|200 ~ 299 | 200 ~ 206 | 성공 |
|300 ~ 399 | 300 ~ 305 | 리다이렉션 |
|400 ~ 499 | 400 ~ 415 | 클라이언트 에러 |
|500 ~ 599 | 500 ~ 505 | 서버 에러 |

500번대까지 있지만, 실제로 사용하는 코드는 많지 않으며 http 가 진화하면서 더 많은 상태코드가 정의될 것이다. 만약 현재 위 코드 외에 다른 코드를 받는다면, 프로토콜 확장으로 직접 정의했을 가능성이 있다.

#### 사유구절
- 응답 시작줄의 마지막 구성 요소이다.
- 상태코드와 대응된다.

#### 버전 번호
- `HTTP/<메이저>.<마이너>` 형식으로 요청, 응답 양쪽에 모두 기술된다.
- 프로토콜 버전을 의미하며, 애플리케이션들에게 대화 상대의 능력과 메시지 형식에 대한 단서를 제공해준다.
- 일부 버전에서는 사용가능한 기능이, 다른 버전에서는 그렇지 않은 경우가 있기 떄문이다.
- 애플리케이션이 지원하는 가장 높은 버전을 가리킨다.

### 2.3. 헤더
- 요청과 응답 메시지에 추가 정보를 더한다.
- 기본적으로 이름/값 쌍의 목록이다.
- 더 많은 내용 [MDN http headers](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers)

|헤더분류 | 정보 |
|---|---|
| 일반 헤더 | 요청, 응답 양쪽 모두애 나타날 수 있음|
|요청 헤더 | 요청에 대한 부가 정보 제공|
| 응답 헤더 | 응답에 대한 부가 정보 제공 |
| 엔티티 헤더 | 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술 |
|확장 헤더 | 명세에 정의되지 않은 새로운 헤더 |

각 헤더는 간단한 문법을 가진다. 이름, 쉼표, 공백(없어도 됨), 필드값, CRLF 가 순서대로 온다.

![headers](https://images.velog.io/images/sanspareilsmyn/post/9ac06f51-7cf6-4ef6-827d-99e49d4265e0/image.png)

#### 헤더를 여러 줄로 나누기
- 긴 헤더줄을 여러줄로 쪼개서 읽기 좋게 만들수 있다.
- 이떄, 추가줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야한다.

### 2.4. 엔터티 본문
- 선택적이며, 메시지의 화물이라고 할 수 있다.
- 이미지, 비디오, html 문서, ... 를 실어나른다.

### 2.5. 버전 0.9 메시지
- 0.9 버전은 프로토콜의 초기 버전으로, 지금의 버전보다 훨씬 단순하다.
- 요청은 메서드, URL 밖에 없었고 응답은 엔터티밖에 없었다.
- 이 엄청난 단순함 때문에, 여러 상황에 대응하기 어려웠고 이후로 여러 값들이 추가 되었다.

## 3. 메서드
- 모든 서버가 모든 메서드를 구현하지는 않는다.
- http 1.1 이라면 GET, HEAD 만 구현해도 된다.
- 메서드는 대부분 제한적이다.(PUT, DELETE는 특히 더)

### 3.1. 안전한 메서드(Safe Method)
- GET, HEAD 메서드가 있다.
- 이 둘은 http 요청의 결과로 서버에 어떠한 작용도 없음을 의미한다.
- 서버 리소스를 조작하지 않고, 그 리소스를 달라고 요청할 뿐이다.
- [멱등성](https://developer.mozilla.org/ko/docs/Glossary/Idempotent)을 가진다.

### 3.2. GET
- 가장 흔히 쓰는 메서드로, 서버에게 리소스를 달라고 요청한다.

![get](https://t1.daumcdn.net/cfile/tistory/21282E3B554A0A1B2C)

### 3.3. HEAD
- GET 과 마찬가지로 리소스를 요청하지만, 서버는 응답으로 헤더만을 돌려준다.
- 엔터티 본문은 반환되지 않는다.
- 리소스 없이 헤더만 조사할 수 있게 하여 리소스의 타입이나, 리소스의 존재 여부(상태 코드로 확인) 을 알 수 있다.
- 서버를 구성할 때 GET, HEAD의 헤더가 정확하게 일치함을 보장해야한다.

### 3.4. PUT
- GET이 문서를 읽어들이는데 반해, PUT은 서버에 문서를 쓴다.
- 기본적인 의미로는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새문서를 만들거나, 이미 URL이 존재한다면 본문을 교체하는 것을 의미한다.
- 서버 콘텐츠를 변경하는 작업이므로, 일반적으로 인가된 사용자인지 확인하는 작업이 필요하다.

### 3.5. POST
- 서버에 입력 데이터를 전송하기 위해 설계 되었다.
- HTML form 을 지원하기 위해 흔히 사용된다.
- form 이 아니더라도, 의미상 입력값을 전달할 때 사용한다.

<details>
<summary>PUT vs POST</summary>
<p>
둘의 차이는 멱등성으로, PUT은 한번을 보내든 여러번을 보내든 같은 효과를 보인다. 즉, 부수 효과가 없다. 하지만 POST는 그렇지 않다.
</p>
</details>

### 3.6. TRACE
- 클라이언트가 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이등의 애플리케이션을 통과할 수 있다.
- 이들에게는 원래의 http 요청을 수정할 수 있는 기회가 있다.
- TRACE는 메서드가 최종적으로 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
- TRACE 요청은 목적지 서버에서 `루프백(loopback)` 진단을 시작한다.
- 서버는 자신이 받은 요청 메시지를 본문에 넣어 응답으로 되돌려준다.
- 클라이언트 ~ 서버 사이의 모든 애플리케이션들의 요청/응답 연쇄를 따라가면서 메시지가 어떻게 변화되었는지 히스토리를 볼 수 있다.
- 주로 진단을 위해 사용되며, 프락시나 다른 애플리케이션이 요청에 어떤 영향을 미치는지 확인해보고자 할 때 좋은 도구다.
  - 하지만 TRACE는 중간 애플리케이션이 여러 다른 종류의 요청을 일관되게 다룬다고 가정하는 문제가 있다.
  - 많은 http 애플리케이션은 메서드에 따라 다르게 동작한다. 그런데 TRACE는 메서드를 구별하는 메커니즘을 제공하진 않는다.
  - TRACE를 어떻게 처리할 것인지에 대해서는 중간 애플리케이션이 결정을 내린다.

<details>
<summary>Try</summary>

cmd 에 아래 명령어를 입력하면 내용을 볼 수 있는데, google은 trace 메서드를 막아놨다. (브라우저에서 요청한게 아니라 그럴 수도 있고)
```
curl -v -X TRACE https://www.google.com
```
~~OPTIONS는 거절됨,,~~

</details>

### 3.7. OPTIONS
- 웹 서베에게 가능한 메서드를 물어본다.

### 3.8. DELETE
- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
- 실제로 삭제되는 것을 보장하지는 못한다. 인가되지 않은 사용자의 요청이나 이미 존재하지 않거나, 지울 수 없는 리소스를 삭제하지 않는다.
- 응답으로 결과로 삭제 여부등을 알려준다.

### 3.9. 확장 메서드
- http는 필요에 따라 확장해도 문제가 없도록 설계되어서, 새로운 기능을 추가해도 과거에 구현된 소프트웨어들의 오작동을 유발하지 않는다.
- 확장메서드는 http/1.1 에 정의되지 않은 메서드로, 서버의 개발자들이 개별적으로 구현한다.
- 확장 메서드의 대표적인 예는 다음과 같다.

|메서드|설명|
|---|---|
|LOCK|리소스를 잠글 수 있게 한다. 동시편접을 막는 등|
|MKCOL|문서를 생성할 수 있게 한다|
|COPY|리소스 복사|
|MOVE|리소스 이동|

- 직접 확장 메서드를 만들거나, 확장 메서드를 가지는 애플리케이션과 통신하는 경우 http가 이해할 수 없는 경우가 있다.
- 프락시는 종단간의 행위를 망가뜨리지 않는한, 알려지지 않은 메서드라도 다운스트림으로 서버에 전달하려고 시도한다.
- 그렇지 않다면 프락시는 501 Not Implement 상태 코드로 응답해야한다.
- 확장 메서드를 다룰 때는 `엄격하게 보내고 관대하게 받아들여라` 라는 오랜 규칙을 따르는 것이 좋다.

## 4. 상태코드
http 상태코드는 크게 다섯가지로 나뉜다. 상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다. http/1.1 에서는 사유구절을 포함시켰다.

### 4.1. 100 - 199 정보성 상태 코드
- http/1.1 에서 도입되었다.
- 비교적 새로운 것으로, 복잡함을 감수할만한 가치가 있는지에 대해 논란이 되고 있다.

|상태코드|사유구절|의미|
|100|Continue|요청의 시작부분 일부가 받아들여졌으며, 클라이언트는 나머지를 이어서 보내야함을 의미. 이것을 보낸 후, 서버는 반드시요청을 받아 응답해야한다.|
|101|Switching Protocol|클라이언트가 Upgrade 헤더에 나열한 것중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.|

100 Continue 는 클라이언트가 서버에 엔터티 본문을 전송하기 전에 서버가 이를 받아들일 것인지 확인하려고 할떄, 그 작업을 최적화하기 위한 의도로 도입되었는데, 이는 프로그래머를 혼란스럽게 하는 경향이 있다.

#### 클라이언트와 100 Continue
